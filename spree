#!/usr/bin/env Rscript

###---START MESSAGE---###
version <- "beta"
cat(paste0('\033[1;36m\nThank you for using spree ',version,'!\n\033[0m', sep = "\n"))

args <- commandArgs(trailingOnly = TRUE)
taxon <- args[1]
input <- args[2]
output <- args[3]
threads <- args[4]

if(is.na(threads)){
  threads <- 1
}

###---HELP---###
if(is.na(taxon) | taxon == "-h" | taxon == "--help" | taxon == "-help"){
  message <- "Usage: spree [ncbi taxon] [path to assembly (.fasta)] [path to output directory] [threads (default 1)]\n"
  example1 <- "Example 1: spree Streptococcus strep_ios1.fasta ./strep_analysis 4"
  example2 <- "Example 2: spree 1301 strep_ios1.fasta ./strep_analysis 4\n"
  cat(message,sep="\n")
  cat(example1,sep="\n")
  cat(example2,sep="\n")
  q("no")
}

###---LOAD PACKAGES---###
cat("\033[1mLoading packages...\033[0m")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggnewscale))
suppressPackageStartupMessages(library(treeio))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(phangorn))
suppressPackageStartupMessages(library(progress))

  cat("\033[1;32mDone\033[0m",sep="\n")

###---CHECK INPUT---###
# check that assembly exists
cat("\033[1mChecking input...\033[0m")
if (!file.exists(input)) {
  # if file doesn't exist, print error message and exit program
  cat("Error: input file not found.\n")
  q("no")
}
input.name <- input %>%
  gsub(pattern = ".*/", replacement = "") %>%
  gsub(pattern = "\\.*$", replacement = "")
cat("\033[1;32mDone\033[0m",sep="\n")

###---CHECK OUTPUT---###
# fix output
output <- output %>% 
  gsub(pattern = "/$", replacement = "") %>% 
  gsub(pattern = "$", replacement = "/")
# check that output exists
cat("\033[1mChecking output...\033[0m")
dir.create(output, showWarnings = F)
cat("\033[1;32mDone\033[0m",sep="\n")

###---DEFINE FILE NAMES---###
ncbi_file <- paste0(output,taxon,"-ncbi.tsv")
select_file <- paste0(output,taxon,'-select-refs.tsv')
meta_file <- paste0(output,input.name,"-metadata.csv")
mash_tree_file <- paste0(output,input.name,"-mash-ava.tree")
mash_top_10 <- paste0(output,input.name,"-mash-top-10.tsv")
mash_tree_image <- paste0(output,input.name,"-mash-tree.jpg")

###---DETERMINE IF TAXON HAS BEEN RUN---###
cat("\033[1mChecking if taxon has been run...\033[0m")
if(!(dir.exists(paste0(output,taxon)))){
    cat("\033[1;32mDone\033[0m",sep="\n")
  ###---GET ASSEMBLIES SUMMARY FOR TAXON---###
  cat(paste0("\033[1mFetching ",taxon," data from NCBI...\033[0m"))
  # run NCBI-Datasets
  system(paste0("datasets summary genome taxon ",
               taxon,
  " --as-json-lines | dataformat tsv genome --fields accession,assmstats-genome-coverage,organism-name,assmstats-total-sequence-len,assminfo-status,assminfo-level,organism-tax-id,source_database > ", ncbi_file))
  
  # load result
  ## check for output
  # check if file exists
  if (!file.exists(paste0(output,taxon,'-ncbi.tsv'))) {
    # if file doesn't exist, print error message and exit program
    cat(paste0("Error: ",output,taxon,"-ncbi.tsv not found.\n"))
    q("no")
  } else {
    df.ncbi <- read_tsv(paste0(output,taxon,'-ncbi.tsv'), show_col_types = FALSE)
  }
  cat("\033[1;32mDone\033[0m",sep="\n")
  
  ###---CLEAN NCBI SUMMARY---###
  cat("\033[1mCleaning the dataset...\033[0m")
  # select only current assemblies
  df.ncbi <- df.ncbi %>%
    subset(`Assembly Status` == "current")
  
  # extract species names
  extract_species <- function(row) {
    words <- strsplit(row, " ")[[1]]
    if (grepl(pattern = "subsp", row)){
      return(paste(words[1:4], collapse = " "))
    }
    if (length(words) >= 2) {
      return(paste(words[1:2], collapse = " "))
    } else {
      return(NA)
    }
  }
  df.ncbi$Species <- unlist(lapply(df.ncbi$`Organism Name`, FUN=extract_species))
  
  # remove unwanted species
  df.ncbi <- df.ncbi[grep(x=df.ncbi$Species, pattern= "(uncultured| sp.| spp.)",invert=T),]
  
  # remove RefSeq/GenBank redundancy
  refseq_in_genbank <- df.ncbi %>%
    subset(`Source Database` == 'SOURCE_DATABASE_REFSEQ') %>%
    mutate(genbank_accession = gsub(`Assembly Accession`, pattern = "GCF", replacement = "GCA")) %>%
    .[["genbank_accession"]]
  df.ncbi <- df.ncbi[!(df.ncbi$`Assembly Accession` %in% refseq_in_genbank),]
  
  # total counts to species names
  df.ncbi <- df.ncbi %>%
    group_by(Species) %>%
    count() %>%
    merge(df.ncbi, by = "Species") %>%
    mutate(Species = paste0(Species," (n=",n,")"))
  
  # add index to each species name and accession name
  n_species <- unique(df.ncbi$Species)
  index.table <- data.frame(Species = n_species, index = seq(from=1, to=length(n_species))) %>%
    mutate(index_species = paste0("[",index,"] ",Species))
  df.ncbi <- df.ncbi %>%
    merge(index.table, by="Species") %>% 
    mutate(Species = factor(index_species, levels = unique(index_species)),
           name = paste0("[",index,"] ",`Assembly Accession`))
  
  # clean up coverage values
  df.ncbi$`Assembly Stats Genome Coverage` <- as.numeric(gsub(pattern = "x", replacement = "", df.ncbi$`Assembly Stats Genome Coverage`))
  cat("\033[1;32mDone\033[0m",sep="\n")
  
  ###---ASSIGN QUALITY STATUS---###
  cat("\033[1mAssesing assembly quality...\033[0m")
  # coverage status
  df.ncbi <- df.ncbi %>%
    mutate(Coverage_Status = case_when(`Assembly Stats Genome Coverage` > 30 ~ TRUE,
                                       TRUE ~ FALSE))
  # database status
  df.ncbi <- df.ncbi %>%
    mutate(Database_Status = case_when(`Source Database` == 'SOURCE_DATABASE_REFSEQ' ~ TRUE,
                                       TRUE ~ FALSE),
           `Source Database` = factor(`Source Database`, levels = c('SOURCE_DATABASE_REFSEQ', 'SOURCE_DATABASE_GENBANK')))
  # complete status
  df.ncbi <- df.ncbi %>%
    mutate(Complete_Status = case_when(`Assembly Level` == 'Complete Genome' ~ TRUE,
                                       TRUE ~ FALSE),
           `Assembly Level` = factor(`Assembly Level`, levels = c('Complete Genome','Scaffold','Contig','Chromosome')))
  # outlier status - TRUE means it is not an outlier
  df.ncbi <- df.ncbi %>% 
    group_by(Species) %>%
    mutate(gl_mean = mean(`Assembly Stats Total Sequence Length`),
           gl_sd = sd(`Assembly Stats Total Sequence Length`)) %>%
    mutate(Outlier_Status = case_when(abs(gl_mean - `Assembly Stats Total Sequence Length`) <= gl_sd*3 ~ TRUE,
                                      TRUE ~ FALSE)) %>%
    select(-gl_mean, -gl_sd) %>%
    ungroup()
  
  # create summary
  df.ncbi$Status_Counts <- df.ncbi$`Coverage_Status`+df.ncbi$`Database_Status`+df.ncbi$`Complete_Status`+df.ncbi$`Outlier_Status`
  df.ncbi <- df.ncbi %>%
    group_by(`Assembly Accession`) %>%
    mutate(Overall_Status = paste(rep('*', Status_Counts), collapse = '')) %>%
    select(-Status_Counts)
  cat("\033[1;32mDone\033[0m",sep="\n")
  
  ###---SELECT REFEREANCES---###
  cat("\033[1mSelecting references...\033[0m")
  select_refs <- function(species){
    # subset by group
    refs <- df.ncbi[df.ncbi$Species == species,] %>%
      arrange(`Source Database`, `Assembly Level`, desc(Outlier_Status), desc(Coverage_Status))
    return(refs[1:5,])
    
  }
  
  df.select <- do.call(rbind, lapply(unique(df.ncbi$Species), FUN = select_refs)) %>% 
    drop_na(`Assembly Accession`)
  # write output
  write.table(x = df.select, select_file, row.names = F, quote = F, sep = '\t')
  # count number of references
  n_ref <- nrow(df.select)
  cat("\033[1;32mDone\033[0m",sep="\n")
  
  ###---DOWNLOAD REFERENCES---###
  cat(paste0("\033[1mDownloading ",n_ref," references:\033[0m"), sep="\n")
  # create taxon specific directory
  dir.create(paste0(output,taxon), showWarnings = F)
  # function for downloading reference genomes
  ## progress bar
  pb <- progress_bar$new(format = "(:spin) [:bar] :percent [Elapsed time: :elapsedfull || Estimated time remaining: :eta]",
                         total = n_ref,
                         complete = "=",
                         incomplete = "-",
                         current = ">",
                         clear = FALSE,
                         width=100)
  ## function
  download_refs <- function(a){
    # progress bar
    pb$tick()
    # download assemblies
    system(paste0("datasets download genome accession ",
                 a,
                 " > /dev/null 2>&1 && unzip ncbi_dataset.zip > /dev/null 2>&1 && cp ncbi_dataset/data/*/*.fna ",output,taxon,"/ > /dev/null 2>&1 && rm -r ncbi_dataset* README.md > /dev/null 2>&1"))
  }
  ## apply function
  tmp <- lapply(df.select$`Assembly Accession`, FUN=download_refs)
  cat("\033[1;32mDone\033[0m",sep="\n")
}else{
  cat("\033[1;32mDone\033[0m",sep="\n")
  cat("\033[1;33mTaxon has been run before - using existing references\033[0m",sep="\n")
  }
###---RUN MASH---###
cat("\033[1mRunning Mash...\033[0m", sep="\n")
system(paste0("mash sketch -p 4 -o ",output,"sketch.msh ",output,taxon,"/* ",
              input,
              " && mash dist -p 4 ",output,"sketch.msh ",output,"sketch.msh > ",output,"mash-ava.tsv"))
cat("\033[1;32mDone\033[0m",sep="\n")

###---LOAD METADATA & MASH RESULTS---###
cat("\033[1mPreparing metadata...\033[0m")
# prepare metadata
input.name <- str_split(input, pattern = "/") %>% 
  unlist()
input.name <- input.name[length(input.name)]
input.meta <- data.frame("Assembly Accession" = input.name, 
                         name=input.name, 
                         Species = NA, 
                         Overall_Status = NA,
                         face="bold",
                         type="Sample") %>%
  rename("Assembly Accession"=Assembly.Accession)
df.select <- read_tsv(paste0(output,taxon,'-select-refs.tsv'), show_col_types = F)
meta <- df.select %>%
  select(`Assembly Accession`, name, Species, Overall_Status) %>%
  mutate(name = paste(name,Overall_Status, sep=" "),
         face="plain",
         type="Reference") %>%
  rbind(input.meta)
write.csv(meta, file=meta_file)
cat("\033[1;32mDone\033[0m",sep="\n")

# load mash file
cat("\033[1mLoading Mash results...\033[0m")
mash.all <- read_tsv(paste0(output,"mash-ava.tsv"), col_names = F, show_col_types = FALSE)
# clean up names
clean_names <- function(name){
  name <- gsub(pattern = ".*/", replacement = "", name) %>%
    gsub(pattern = "\\.*$", replacement = "")
  if(grepl(pattern = "^(GCA|GCF)_.*", name)){
    name <- substr(start = 1, stop = 15, name)
  }
  return(name)
}
mash.all$X1<- lapply(mash.all$X1, FUN=clean_names) %>% unlist()
mash.all$X2 <- lapply(mash.all$X2, FUN=clean_names) %>% unlist()
cat("\033[1;32mDone\033[0m",sep="\n")

# get top hit info
cat("\033[1mGetting ten closest genomes...\033[0m")
mash.top.10 <- mash.all %>%
  subset(X1 == input.name) %>%
  subset(X1 != X2) %>% 
  mutate(`% Matching Kmers` = as.numeric(gsub(X5, pattern="/1000", replacement = ""))/10) %>% 
  rename("Assembly Accession"=X2, "Mash Distance"=X3) %>%
  merge(df.select[,c("Assembly Accession","Species")]) %>%
  select(`Assembly Accession`, Species, `Mash Distance`,`% Matching Kmers`)
mash.top.10 <- mash.top.10[order(mash.top.10$`Mash Distance`),][1:10,]
# write to file
write.table(x = mash.top.10, mash_top_10, row.names = F, quote = F, sep = '\t')
cat("\033[1;32mDone\033[0m",sep="\n")
  
###---MAKE TREE---###
cat("\033[1mBuilding the Mash tree...\033[0m")
# convert to matrix
mash.all <- mash.all[,1:3] %>% 
  unique() %>% 
  spread(key = "X2", value = "X3") %>% column_to_rownames(var="X1") %>% 
  as.matrix()
# create distance matrix
dist <- dist(mash.all, method = "euclidean")
# create tree and save
upgma <- upgma(dist)
write.tree(phy = upgma, file = mash_tree_file)

# make tree image
## initial plot
p_mash.tree <- ggtree(upgma,layout = "circular")
## get sizing info
size_tree <- function(plot){
  # extract plot data
  data <- plot$data
  # determine limits
  ## max sample name length
  max_name <- nchar(data$label) %>% max(na.rm = T)
  if(max_name > 100){
    max_name <- 30
  }
  ## max x-coordinate
  max_x <- max(data$x)
  return(list(max_name,max_x))
}
maxs <- size_tree(p_mash.tree) %>% unlist()
name_size=as.numeric(maxs[1])/15
x_max=as.numeric(maxs[2])*1.2
## re-plot tree
p_mash.tree <- p_mash.tree %<+% meta+
  geom_tiplab(aes(label=name, color=type), size=name_size, fontface="bold")+
  scale_color_manual(values = c("#009688","black"), breaks = c("Sample","Reference"))+
  labs(color="Sample Type")+
  new_scale_color()+
  geom_tippoint(aes(color=Species))+
  xlim(0,as.numeric(x_max))+
  ggtitle("UPGMA Mash Tree",subtitle = paste0("Taxon: ",taxon," Sample: ", input.name))
## save image
n_iso <- p_mash.tree$data %>%
  drop_na() %>%
  nrow()
# set image dimensions
wdth <- n_iso/5
if(wdth < 6){
  wdth <- 6
}
hght=n_iso/5
if(hght < 6){
  hght <- 6
}

# save plot
ggsave(plot = p_mash.tree, filename = mash_tree_image, width = wdth, height = hght, dpi = 300, limitsize = F)
cat("\033[1;32mDone\033[0m",sep="\n")

###---REPORT FILES---###
cat("\n\033[1m####### OUTPUT FILES #######\033[0m\n",sep="\n")

cat("\033[1m## Genus-specific Files (Reusable) ##\033[0m",sep="\n")
cat(paste0("\n\033[1mAll NCBI Metadata: \033[0m",ncbi_file),sep="\n")
cat(paste0("\033[1mSelect References Metadata: \033[0m",select_file),sep="\n")

cat("\n\033[1m## Isolate-specific Files ##\033[0m\n",sep="\n")
cat(paste0("\033[1mMash Tree Metadata: \033[0m",meta_file),sep="\n")
cat(paste0("\033[1mMash Tree Image: \033[0m",mash_tree_image),sep="\n")
cat(paste0("\033[1mMash Newick File: \033[0m",mash_tree_file),sep="\n")
cat(paste0("\033[1mMash Top 10: \033[0m",mash_top_10),sep="\n")

###---REPORT TOP 10---###
cat("\n\033[1m####### TOP 10 CLOSEST GENOMES #######\033[0m")
mash.top.10 %>%
  knitr::kable(row.names = F)

###---CLEAN UP---##
system(paste0("rm ",output,"sketch.msh ",output,"mash-ava.tsv"))