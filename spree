#!/usr/bin/env Rscript --vanilla

###---START MESSAGE---###
version <- "beta"
cat(paste0('Thank you for using spree ',version,'!\n', sep = "\n"))

args <- commandArgs(trailingOnly = TRUE)
taxon <- args[1]
input <- args[2]
threads <- args[3]

if(is.na(threads)){
  threads <- 1
}

###---HELP---###
if(taxon == "-h" | taxon == "--help" | taxon == "-help"){
  message <- "Usage: spree [ncbi taxon] [path to assembly (.fasta)] [threads (default 1)]\n"
  cat(message,sep="\n")
  q("no")
}

###---LOAD PACKAGES---###
cat("loading packages...")
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(ggnewscale))
suppressPackageStartupMessages(library(treeio))
suppressPackageStartupMessages(library(ggtree))
suppressPackageStartupMessages(library(phangorn))
cat("Done.",sep="\n")

###---CHECK INPUT---###
# check that assembly exists
cat("Checking input...")
if (!file.exists(input)) {
  # if file doesn't exist, print error message and exit program
  cat("Error: input file not found.\n")
  q("no")
}
input.name <- input %>%
  gsub(pattern = ".*/", replacement = "") %>%
  gsub(pattern = "\\.*$", replacement = "")
cat("Done.", sep="\n")
# determine if taxon has been run before
cat("Checking if taxon has been run...")
if(!(dir.exists(taxon))){
  cat("Done.",sep="\n")
  ###---GET ASSEMBLIES SUMMARY FOR TAXON---###
  cat(paste0("Fetching all genome data for taxon ",taxon," from NCBI..."))
  # run NCBI-Datasets
  system(paste0("datasets summary genome taxon ",
               taxon,
  " --as-json-lines | dataformat tsv genome --fields accession,assmstats-genome-coverage,organism-name,assmstats-total-sequence-len,assminfo-status,assminfo-level,organism-tax-id,source_database > ",taxon,"-ncbi.tsv"))
  
  # load result
  ## check for output
  # check if file exists
  if (!file.exists(paste0(taxon,'-ncbi.tsv'))) {
    # if file doesn't exist, print error message and exit program
    cat("Error: ncbi.tsv not found.\n")
    q("no")
  } else {
    df.ncbi <- read_tsv(paste0(taxon,'-ncbi.tsv'), show_col_types = FALSE)
  }
  cat("Done.",sep="\n")
  
  ###---CLEAN NCBI SUMMARY---###
  cat("Cleaning the dataset...")
  # select only current assemblies
  df.ncbi <- df.ncbi %>%
    subset(`Assembly Status` == "current")
  
  # extract species names
  extract_species <- function(row) {
    words <- strsplit(row, " ")[[1]]
    if (grepl(pattern = "subsp", row)){
      return(paste(words[1:4], collapse = " "))
    }
    if (length(words) >= 2) {
      return(paste(words[1:2], collapse = " "))
    } else {
      return(NA)
    }
  }
  df.ncbi$Species <- unlist(lapply(df.ncbi$`Organism Name`, FUN=extract_species))
  
  # remove unwanted species
  df.ncbi <- df.ncbi[grep(x=df.ncbi$Species, pattern= "(uncultured| sp.| spp.)",invert=T),]
  
  # remove RefSeq/GenBank redundancy
  refseq_in_genbank <- df.ncbi %>%
    subset(`Source Database` == 'SOURCE_DATABASE_REFSEQ') %>%
    mutate(genbank_accession = gsub(`Assembly Accession`, pattern = "GCF", replacement = "GCA")) %>%
    .[["genbank_accession"]]
  df.ncbi <- df.ncbi[!(df.ncbi$`Assembly Accession` %in% refseq_in_genbank),]
  
  # total counts to species names
  df.ncbi <- df.ncbi %>%
    group_by(Species) %>%
    count() %>%
    merge(df.ncbi, by = "Species") %>%
    mutate(Species = paste0(Species," (n=",n,")"))
  
  # add index to each species name and accession name
  n_species <- unique(df.ncbi$Species)
  index.table <- data.frame(Species = n_species, index = seq(from=1, to=length(n_species))) %>%
    mutate(index_species = paste0("[",index,"] ",Species))
  df.ncbi <- df.ncbi %>%
    merge(index.table, by="Species") %>% 
    mutate(Species = factor(index_species, levels = unique(index_species)),
           name = paste0("[",index,"] ",`Assembly Accession`))
  
  # clean up coverage values
  df.ncbi$`Assembly Stats Genome Coverage` <- as.numeric(gsub(pattern = "x", replacement = "", df.ncbi$`Assembly Stats Genome Coverage`))
  cat("Done.",sep="\n")
  
  ###---ASSIGN QUALITY STATUS---###
  cat("Assesing assembly quality...")
  # coverage status
  df.ncbi <- df.ncbi %>%
    mutate(Coverage_Status = case_when(`Assembly Stats Genome Coverage` > 30 ~ TRUE,
                                       TRUE ~ FALSE))
  # database status
  df.ncbi <- df.ncbi %>%
    mutate(Database_Status = case_when(`Source Database` == 'SOURCE_DATABASE_REFSEQ' ~ TRUE,
                                       TRUE ~ FALSE),
           `Source Database` = factor(`Source Database`, levels = c('SOURCE_DATABASE_REFSEQ', 'SOURCE_DATABASE_GENBANK')))
  # complete status
  df.ncbi <- df.ncbi %>%
    mutate(Complete_Status = case_when(`Assembly Level` == 'Complete Genome' ~ TRUE,
                                       TRUE ~ FALSE),
           `Assembly Level` = factor(`Assembly Level`, levels = c('Complete Genome','Scaffold','Contig','Chromosome')))
  # outlier status - TRUE means it is not an outlier
  df.ncbi <- df.ncbi %>% 
    group_by(Species) %>%
    mutate(gl_mean = mean(`Assembly Stats Total Sequence Length`),
           gl_sd = sd(`Assembly Stats Total Sequence Length`)) %>%
    mutate(Outlier_Status = case_when(abs(gl_mean - `Assembly Stats Total Sequence Length`) <= gl_sd*3 ~ TRUE,
                                      TRUE ~ FALSE)) %>%
    select(-gl_mean, -gl_sd) %>%
    ungroup()
  
  # create summary
  df.ncbi$Status_Counts <- df.ncbi$`Coverage_Status`+df.ncbi$`Database_Status`+df.ncbi$`Complete_Status`+df.ncbi$`Outlier_Status`
  df.ncbi <- df.ncbi %>%
    group_by(`Assembly Accession`) %>%
    mutate(Overall_Status = paste(rep('*', Status_Counts), collapse = '')) %>%
    select(-Status_Counts)
  
  ###---SELECT REFEREANCES---###
  cat("Selecting references...")
  select_refs <- function(species){
    # subset by group
    refs <- df.ncbi[df.ncbi$Species == species,] %>%
      arrange(`Source Database`, `Assembly Level`, desc(Outlier_Status), desc(Coverage_Status))
    return(refs[1:5,])
    
  }
  
  df.select <- do.call(rbind, lapply(unique(df.ncbi$Species), FUN = select_refs)) %>% 
    drop_na(`Assembly Accession`)
  
  write.table(x = df.select, paste0(taxon,'-select-refs.tsv'), row.names = F, quote = F, sep = '\t')
  cat("Done.",sep="\n")
  
  ###---DOWNLOAD REFERENCES---###
  cat(paste0("Downloading ",nrow(df.select)," references..."))
  # create taxon specific directory
  dir.create(taxon, showWarnings = F)
  # function for downloading reference genomes
  download_refs <- function(a){
    system(paste("datasets download genome accession ",
                 a,
                 " && unzip ncbi_dataset.zip && cp ncbi_dataset/data/*/*.fna ",taxon," && rm -r ncbi_dataset* README.md"))
  }
  
  tmp <- lapply(df.select$`Assembly Accession`, FUN=download_refs)
  cat("Done.",sep="\n")
}else{
  cat("Done",sep="\n")
  cat("\tTaxon has been run before - using existing references",sep="\n")
  }
###---RUN MASH---###
cat("Running Mash...", sep="\n")
system(paste0("mash sketch -p 4 -o sketch.msh ",taxon,"/* ",
              input,
              " && mash dist -p 4 sketch.msh sketch.msh > mash-ava.tsv"))
cat("Done.",sep="\n")

###---LOAD METADATA & MASH RESULTS---###
cat("Preparing metadata...")
# prepare metadata
input.name <- str_split(input, pattern = "/") %>% unlist()
input.meta <- data.frame("Assembly Accession" = input, 
                         name=input.name[max(length(input.name))], 
                         Species = NA, 
                         Overall_Status = NA,
                         face="bold",
                         type="Sample") %>%
  rename("Assembly Accession"=Assembly.Accession)
df.select <- read_tsv(paste0(taxon,'-select-refs.tsv'), show_col_types = F)
meta <- df.select %>%
  select(`Assembly Accession`, name, Species, Overall_Status) %>%
  mutate(name = paste(name,Overall_Status, sep=" "),
         face="plain",
         type="Reference") %>%
  rbind(input.meta)
write.csv(meta, file=paste0(input.name,"-metadata.csv"))
cat("Done.",sep="\n")

# load mash file
cat("Loading Mash results...")
mash.all <- read_tsv("mash-ava.tsv", col_names = F, show_col_types = FALSE)
# clean up names
clean_names <- function(name){
  name <- gsub(pattern = ".*/", replacement = "", name) %>%
    gsub(pattern = "\\.*$", replacement = "")
  if(grepl(pattern = "^(GCA|GCF)_.*", name)){
    name <- substr(start = 1, stop = 15, name)
  }
  return(name)
}
mash.all$X1<- lapply(mash.all$X1, FUN=clean_names) %>% unlist()
mash.all$X2 <- lapply(mash.all$X2, FUN=clean_names) %>% unlist()
cat("Done.", sep="\n")

# get top hit info
cat("Getting ten closest genomes...")
mash.top.10 <- mash.all %>%
  subset(X1 == input.name) %>%
  subset(X1 != X2) %>% 
  mutate(`% Matching Kmers` = as.numeric(gsub(X5, pattern="/1000", replacement = ""))/10) %>% 
  rename("Assembly Accession"=X2, "Mash Distance"=X3) %>%
  merge(df.select[,c("Assembly Accession","Species")]) %>%
  select(`Assembly Accession`, Species, `Mash Distance`,`% Matching Kmers`)
mash.top.10 <- mash.top.10[order(mash.top.10$`Mash Distance`),][1:10,]
cat("Done.",sep="\n")
  
###---MAKE TREE---###
cat("Building the Mash tree...")
# convert to matrix
mash.all <- mash.all[,1:3] %>% 
  unique() %>% 
  spread(key = "X2", value = "X3") %>% column_to_rownames(var="X1") %>% 
  as.matrix()
# create distance matrix
dist <- dist(mash.all, method = "euclidean")
# create tree and save
upgma <- upgma(dist)
write.tree(phy = upgma, file = paste0(input.name,"-mash-ava.tree"))

# make tree image
## initial plot
p_mash.tree <- ggtree(upgma,layout = "circular")
## get sizing info
size_tree <- function(plot){
  # extract plot data
  data <- plot$data
  # determine limits
  ## max sample name length
  max_name <- nchar(data$label) %>% max(na.rm = T)
  if(max_name > 100){
    max_name <- 30
  }
  ## max x-coordinate
  max_x <- max(data$x)
  return(list(max_name,max_x))
}
maxs <- size_tree(p_mash.tree) %>% unlist()
name_size=as.numeric(maxs[1])/15
x_max=as.numeric(maxs[2])*1.2
## re-plot tree
p_mash.tree <- p_mash.tree %<+% meta+
  geom_tiplab(aes(label=name, color=type), size=name_size, fontface="bold")+
  scale_color_manual(values = c("#009688","black"), breaks = c("Sample","Reference"))+
  labs(color="Sample Type")+
  new_scale_color()+
  geom_tippoint(aes(color=Species))+
  xlim(0,as.numeric(x_max))+
  ggtitle("UPGMA Mash Tree",subtitle = paste0("Taxon: ",taxon," Sample: ", input.name))
## save image
n_iso <- p_mash.tree$data %>%
  drop_na() %>%
  nrow()
# set image dimensions
wdth <- n_iso/5
if(wdth < 6){
  wdth <- 6
}
hght=n_iso/5
if(hght < 6){
  hght <- 6
}

ggsave(plot = p_mash.tree, filename = paste0(input.name,"-mash-tree.jpg"), width = wdth, height = hght, dpi = 300, limitsize = F)
cat("Done.",sep="\n")



###---REPORT TOP 10---###
mash.top.10 %>%
  knitr::kable(row.names = F)
write.table(x = mash.top.10, paste0(input.name,"-mash-top-10.jpg"), row.names = F, quote = F, sep = '\t')

###---CLEAN UP---##
system("rm sketch.msh mash-ava.tsv")